\documentclass[a4paper,graphics,11pt]{article}
\pagenumbering{arabic}

\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[ngerman]{babel}
\usepackage{amsmath, tabu}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{complexity}
\usepackage{mathtools}
\usepackage{setspace}
\usepackage{graphicx,color,curves,epsf,float,rotating}
\usepackage{tasks}
\usepackage{delarray}
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\newcommand{\up}[2]{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny #2}}}{#1}}}
\newcommand{\vect}[5]{\begin{pmatrix}#1\\#2\\#3\\#4\\#5\end{pmatrix}}
\newcommand{\eps}[0]{\varepsilon}
\newcommand{\godel}[1]{\langle #1 \rangle}
\newcommand{\Iff}[0]{\,\Longleftrightarrow\,}

\begin{document}

\begin{center}
    \LARGE \textbf{Probleme}
\end{center}

\section*{Entscheidbare Probleme}
\begin{itemize}
    \item Gegeben CFG $\godel{G}$, ist $L(G)$ leer / endlich / $w \in L(G)$ für ein festes $w \in \Sigma^*$.
\end{itemize}

\section*{Unentscheidbare Probleme}

Komplemente werden im folgenden weggelassen, da offensichtlich auch unentschiedbar.
\begin{itemize}
    \item Diagonalsprache $D := \{w \in \{0,1\}^* \mid w = w_i \text{ und } M_i \text{ akzeptiert } w \text{ nicht}\}$
    \\
\item Halteproblem $H := \{\godel{M} w \mid M \text{ hält auf } w\}$.
\item $\eps$-Halteproblem $H_\eps := \{\godel{M} \mid M \text{ hält auf } \eps \}$.
    \item Totales Halteproblem $H_{tot} := \{\godel{M} \mid M \text{ hält auf allen Eingaben}\}$.
    \item $H_{never} := \{\godel{M} \mid M \text{ hält auf keiner Eingabe}\}$
    \\
    \item PCP, MPCP und PCP mit 5 oder mehr als 7 Dominos
    \\
    \item Besitzt eine elementare Funktion eine elementare Stammfunktion? (Satz von Richardson)
    \item Dioph $:= \{\godel{p} \mid p \text{ multivariates Polynom über $\mathbb{Z}$ mit Nullstelle in $\mathbb{Z}$}\}$
    \\
    \item Gegeben $\godel{M}$, ist $L(M) = \Sigma^*$  / leer / (un)endlich / regulär / kontext-frei?
    \item Gegeben CFG $\godel{G}$, ist $G$ eindeutig / $L(G) = \Sigma^*$ / $L(G)$ regulär?
    \item Gegeben CFG $\godel{G}$, enthält $L(G)$ ein Palindrom?
    \item Gegeben CFGs $\godel{G_1}, \godel{G_2}$, ist $L(G_1) \subseteq L(G_2)$ / $L(G_1) \cap L(G_2) = \varnothing$?
    \\
    \item Alle nicht-rekursiv-aufzählbaren Probleme (siehe unten).
\end{itemize}

\newpage

\section*{Rekursiv-aufzählbare Probleme}
\begin{itemize}
    \item $H$
    \item $H_\eps$
    \item $\overline{D}$
    \item Dioph
    \item $\{\godel{M}\mid w \in L(M)\}$ für festes Wort $w$.
        (Einfach $M$ auf $w$ simulieren)
\end{itemize}

\section*{Nicht rekursiv-aufzählbare Probleme}
\begin{itemize}
    \item $\overline{H}$
    \item $\overline{H_\eps}$
    \item $H_{tot}$ und $\overline{H_{tot}}$
    \item $H_{never}$
    \item $D$
    \item $\overline{\text{Dioph}}$
    \item $\{\godel{M} \mid M \text{ verwirft alle Eingaben}\}$
    \item $\{\godel{M_1}\godel{M_2} \mid L(M_1) \cap L(M_2) \neq \Sigma^*\}$ (HA 8.3)\\
    \\ Folgende aus Arbeitsheft, beweis via Varianten von Rice.
    \item $\{\godel{M} \mid L(M) = \varnothing\}$
    \item $\{\godel{M} \mid L(M) = \{0,1\}^*\}$
    \item $\{\godel{M} \mid \eps \notin L(M)\}$
    \item $\{\godel{M} \mid L(M) \text{ enthält alle Worte gerader Länge aus }\{0,1\}^* \}$
    \item $\{\godel{M} \mid L(M) \text{ ist regulär}\}$
    \item $\{\godel{M} \mid L(M) \text{ ist nicht regulär}\}$
    \item $\{\godel{M} \mid L(M) \text{ ist rekursiv}\}$
    \item $\{\godel{M} \mid L(M) \text{ ist nicht rekursiv}\}$
    \item $\{\godel{M} \mid |L(M)| = c\}$ für $c \in \mathbb{N}$ fest.
    \item $\{\godel{M} \mid |L(M)| \leq c\}$ für $c \in \mathbb{N}$ fest.
    \item $\{\godel{M} \mid |L(M)| = \infty\}$
\end{itemize}

\newpage

\section*{Probleme in \textsf{P}}

\begin{itemize}
    \item SORTIEREN
    \item Graphzusammenhang
    \item Primzahltest
    \item Eulerkreis
    \item Minimaler Spannbaum
    \item Maximaler Fluss
    \item Maximum Matching
    \item ggT
    \item Konvexe Hülle in 2D
\end{itemize}

\section*{Probleme in \textsf{NP} ({\color{red}\textsf{NP}-vollständig})}

\begin{itemize}
    \item[\color{red}$\bullet$] SAT
    \item[\color{red}$\bullet$] 3-SAT
    \item[\color{red}$\bullet$] CLIQUE
    \item[\color{red}$\bullet$] INDEP-SET
    \item MATCHING
    \item[\color{red}$\bullet$] VERTEX-COVER
    \item DOMINATING-SET
    \item[\color{red}$\bullet$] COLORING
    \item[\color{red}$\bullet$] (D-)HAM-CYCLE
    \item GI
    \item COMPOSITE
    \item[\color{red}$\bullet$] EX-COVER
    \item[\color{red}$\bullet$] SUBSET-SUM
    \item[\color{red}$\bullet$] PARTITION
    \item[\color{red}$\bullet$] KNAPSACK
    \item[\color{red}$\bullet$] BPP
    \item[\color{red}$\bullet$] TSP ($\Delta$-TSP, $\{1,2\}$-TSP)
\end{itemize}

\newpage

\section*{Definitionen}

\textbf{SAT} (\textsf{NP}-vollständig; Satz von Cook und Levin)
\\[5pt]
Eingabe: Eine Aussagenlogische Formel $\varphi$ in CNF über einer Variablenmenge $X = \{x_1,\cdots,x_n\}$.
\\[5pt]
Frage: Ist $\varphi$ erfüllbar (ex. Variablenbelegung, sodass $\varphi \equiv 1$)?

\strut

\textbf{3-SAT} (\textsf{NP}-vollständig; SAT $\leq_p$ 3-SAT)
\\[5pt]
Eingabe: Eine Aussagenlogische Formel $\varphi$ in 3-CNF über einer Variablenmenge $X = \{x_1,\cdots,x_n\}$.\\
\strut\qquad Dabei ist 3-CNF wie CNF, nur dass jede Klausul exakt 3 Literale haben muss.
\\[5pt]
Frage: Ist $\varphi$ erfüllbar (ex. Variablenbelegung, sodass $\varphi \equiv 1$)?

\strut

\textbf{CLIQUE} (\textsf{NP}-vollständig; SAT $\leq_p$ CLIQUE)
\\[5pt]
Eingabe: Ein ungerichteter Graph $G = (V,E)$ und $k \in \mathbb{N}$
\\[5pt]
Frage: Enthält $G$ eine Clique (vollständiger Teilgraph) mit $\geq k$ Knoten?

\strut

\textbf{INDEP-SET} (\textsf{NP}-vollständig; CLIQUE $\leq_p$ INDEP-SET)
\\[5pt]
Eingabe: Ein ungerichteter Graph $G = (V,E)$ und $k \in \mathbb{N}$
\\[5pt]
Frage: Enthält $G$ eine unabhängige Menge ($S \subseteq V$ pw. nicht adjazent) mit $\geq k$ Knoten?

\strut

\textbf{VERTEX-COVER} (\textsf{NP}-vollständig; INDEP-SET $\leq_p$ VERTEX-COVER)
\\[5pt]
Eingabe: Ein ungerichteter Graph $G = (V,E)$ und $k \in \mathbb{N}$
\\[5pt]
Frage: Enthält $G$ ein Vertex-Cover ($S \subseteq V$ berührt alle Kanten) mit $\leq k$ Knoten?

\strut

\textbf{MATCHING}
\\[5pt]
Eingabe: Ein ungerichteter Graph $G = (V,E)$ und $k \in \mathbb{N}$
\\[5pt]
Frage: Enthält $G$ ein Matching mit $\geq k$ Kanten?\\[5pt]
(Matching $M \subseteq E$: Keine 2 Kanten in M haben gemeinsame Knoten).


\strut

\textbf{DOMINATING-SET}
\\[5pt]
Eingabe: Ein ungerichteter Graph $G = (V,E)$ und $k \in \mathbb{N}$
\\[5pt]
Frage: Enthält $G$ ein Dominating-Set mit $\leq k$ Knoten?\\[5pt]
(Dominating-Set $D \subseteq V$: Jeder Knoten ist in $D$ enthalten oder zu einem in $D$ benachbart).

\newpage

\textbf{COLORING} (\textsf{NP}-vollständig; nicht in VL)
\\[5pt]
Eingabe: Ein ungerichteter Graph $G = (V,E)$ und $k \in \mathbb{N}$
\\[5pt]
Frage: Gibt es eine Färbung $c : V \to [1,k]$ sodass $\forall e \in E : c(e_1) \neq c(e_2)$?

\strut

\textbf{D-HAM-CYCLE} (\textsf{NP}-vollständig; SAT $\leq_p$ D-HAM-CYCLE)
\\[5pt]
Eingabe: Ein gerichteter Graph $G = (V,A)$
\\[5pt]
Frage: Besitzt $G$ einen gerichteten Hamiltonkreis?

\strut

\textbf{HAM-CYCLE} (\textsf{NP}-vollständig; D-HAM-CYCLE $\leq_p$ HAM-CYCLE)
\\[5pt]
Eingabe: Ein ungerichteter Graph $G = (V,E)$
\\[5pt]
Frage: Besitzt $G$ einen Hamiltonkreis (geschl. Pfad, der jeden Knoten genau einmal enthält)?

\strut

\textbf{GI}
\\[5pt]
Eingabe: Zwei ungerichtete Graphen $G_1= (V_1,E_1), G_2=(V_2,E_2)$.
\\[5pt]
Frage: Ist $G_1 \cong G_2$, d.h. ex Bijektion $f:V_1 \to V_2$ mit $e \in E_1 \iff (f(e_1),f(e_2)) \in E_2$?

\strut

\textbf{COMPOSITE}
\\[5pt]
Eingabe: $n \in \mathbb{N}$ (kodiert als Binärzahl).
\\[5pt]
Frage: Ist $n$ keine Primzahl?

\strut

\textbf{EX-COVER} (\textsf{NP}-vollständig; nicht in VL)
\\[5pt]
Eingabe: Eine endliche Menge $X$ und $S_1,\cdots,S_M \subseteq X$
\\[5pt]
Frage: Existiert $I \subseteq [1,m]$ sodass $(S_i)_{i \in I}$ eine Parition von $X$ ist?

\strut

\textbf{SUBSET-SUM} (\textsf{NP}-vollständig; 3-SAT $\leq_p$ SUBSET-SUM)
\\[5pt]
Eingabe: $a \in \mathbb{N}^k, b \in \mathbb{N}$
\\[5pt]
Frage: Existiert $I \subseteq [1,k]$ sodass $\displaystyle \sum_{i \in I}a_i = b$?

\strut

\textbf{PARITION} (\textsf{NP}-vollständig; SUBSET-SUM $\leq_p$ PARTITION)
\\[5pt]
Eingabe: $a \in \mathbb{N}^k$ mit $\sum a_i = 2A, A \in \mathbb{N}$.
\\[5pt]
Frage: Existiert $I \subseteq [1,k]$ sodass $\displaystyle \sum_{i \in I}a_i = A$?

\newpage

\textbf{KNAPSACK} (\textsf{NP}-vollständig; SUBSET-SUM $\leq_p$ KP)
\\[10pt]
Eingabe: $w,p \in \mathbb{N}^k$ und $b\in \mathbb{N}$ (und $\gamma \in \mathbb{N}$)
\\[10pt]
Zulässige Lösung: Menge $K \subseteq [1,n]$ mit $w(K) := \sum_{i \in K} w_i \leq b$
\\[10pt]
Optimierungsziel: Maximiere $p(K) := \sum_{i \in K} p_i$
\\[10pt]
Als Entscheidungsproblem: Existiert $K$ sodass $p(k) \geq \gamma$?

\strut

\textbf{BPP} (\textsf{NP}-vollständig; PARTITION $\leq_p$ BPP)
\\[10pt]
Eingabe: $b \in \mathbb{N}$ und $w \in [1,b]^n$ (und $\gamma \in \mathbb{N}$)
\\[10pt]
Zulässige Lösung: $k \in \mathbb{N}$ und $f : [1,n] \to [1,k]$ sodass
$\displaystyle\forall i \in [1,k]: \sum_{j \in f^{-1}(i)} w_j \leq b$\\
(Zuordnung von Gewichten zu Kisten, sodass Tragkraft $b$ der Kisten nicht überschritten wird)
\\[10pt]
Optimierungsziel: Minimiere $k$ (= Anzahl Kisten)
\\[10pt]
Als Entscheidungsproblem: Existiert eine zulässige Lösung mit $k \leq \gamma$?

\strut

$\{1,2\}$-\textbf{TSP} (\textsf{NP}-vollständig, HAM-CYCLE $\leq_p \{1,2\}$-TSP)
\\[5pt]
Eingabe: Städte $1,...,n$; symm. Dist. $d(i,j) \in \{1,2\}$; $\gamma \in \mathbb{N}$
\\[5pt]
Frage: Gibt es eine Rundreise mit Länge höchstens $\gamma$?

\strut

$\Delta$-\textbf{TSP} (\textsf{NP}-vollständig, folgt aus $\{1,2\}$-TSP)
\\[5pt]
Eingabe: Städte $1,...,n$; symm. Dist. $d(i,j)$, welche Dreiecksungleichung erfüllen; $\gamma \in \mathbb{N}$
\\[5pt]
Frage: Gibt es eine Rundreise mit Länge höchstens $\gamma$?

\strut

\textbf{TSP} (\textsf{NP}-vollständig, folgt aus $\{1,2\}$-TSP)
\\[5pt]
Eingabe: $d(i,j) \in \mathbb{N}$ für $1 \leq i \neq j \leq n$ (und $\gamma \in \mathbb{N}$)
\\[5pt]
Zulässige Lösung: Permutation $\pi \in S_n$.
\\[5pt]
Optimierungsziel: Minimiere $\displaystyle d(\pi) := \sum_{i=1}^{n-1} d(\pi_i,\pi_{i+1}) + d(\pi_n, \pi_1)$ 
\\[5pt]
Als Entscheidungsproblem: Existiert eine zulässige Lösung mit $d(\pi) \leq \gamma$?


\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{center}
    \LARGE \textbf{VL-Stoff}
\end{center}

\section{Turing Maschinen I}

\begin{itemize}
    \item Probleme
    \item Turingmaschinen
    \item rekursive / berechenbare Funktionen
    \item rekursive / entscheidbare Sprachen
    \item Konfigurationen
    \item Programmiertechniken: Speicher im Zustandsraum
    \item Programmiertechniken: Mehrspurmaschinen
    \item Programmiertechniken: Weiteres
\end{itemize}

\textbf{Definition:} Probleme
\begin{itemize}
    \item \textbf{Problem als Relation} $R \subseteq \Sigma^* \times \Gamma^*$ für Alphabete $\Sigma, \Gamma$
    \item Es ist $(x,y) \in R \Iff y$ ist zulässige Ausgabe zur Eingabe $x$
    \item Beispiel Primfaktorbestimmung:
        $$
            R := \{(x,y) \in \{0,1\}^* \times \{0,1\}^* \mid x = \text{bin}(q), y = \text{bin}(p), q,p \in \mathbb{N},
            q\geq 2, p \text{ prim}, p \mid q\}
        $$
        \\
    \item Bei eindeutiger Lösung \textbf{Problem als Funktion} $f: \Sigma^* \to \Gamma^*$
    \item Beispiel Multiplikation inklusive Trennzeichen:
        $$
            f : \{0,1,\#\}^* \to \{0,1,\#\}, f(\text{bin}(i_1)\#\text{bin}(i_2)) = \text{bin}(i_1 \cdot i_2)
        $$
        \\
    \item \textbf{Problem als Entscheidungsproblem}: Form $f : \Sigma^* \to \{0,1\}$
    \item $L := f^{-1}(1) \subseteq \Sigma^*$ ist Sprache vom durch $f$ definiertem Entscheidungsproblem.
    \item Beispiel Graphzusammenhang: Bestimme zur Eingabe $G = (V,E)$ ob $G$ zsmhgd.
    \item Wenn Graph $G$ codiert in $\Sigma$ durch $code(G)$, so ist
        $$
            L := \{w \in \Sigma^* \mid \exists \text{ zusammenhängender Graph } G: w = code(G)\}
        $$
        die zu diesem Entscheidungsproblem gehörende Sprache.
\end{itemize}
\newpage


\textbf{Definition:} Turingmaschine (TM)

Eine Turingmaschine $M$ ist gegeben durch $M = (Q, \Sigma, \Gamma, B, q_0, \overline{q}, \delta)$, wobei
\begin{itemize}
    \item $Q$ endliche Zustandsmenge
    \item $\Sigma$ endliches Eingabealphabet
    \item $\Gamma \supsetneq \Sigma$ endliches Bandalphabet
    \item $B \in \Gamma \setminus \Sigma$ Leerzeichen, Blank
    \item $q_0 \in Q$ Anfangszustand
    \item $\overline{q}$ Endzustand
    \item $\delta : (Q \setminus \{\overline{q}\}) \times \Gamma \to Q \times \Gamma \times \{R, L, N\}$
        Zustandsüberführungsfunktion
\end{itemize}

Weiteres:
\begin{itemize}
    \item Startet in $q_0$, Kopf über (1. Symbol vom) Eingabewort eingerahmt von Blanks
    \item TM stoppt, sobald Endzustand $\overline{q}$ erreicht.
    \item Ausgabewort $y \in \Sigma^*$ beginnt Kopfposition und endet vor erstem Symbol in $\Gamma\setminus\Sigma$
    \\
    \item akzeptiert $\Iff$ terminiert und Ausgabe beginnt mit 1
    \item verwirft $\Iff$ terminiert und Ausgabe beginnt nicht mit 1
    \\
    \item \textbf{Laufzeit} ist Anzahl von Zustandsübergängen bis zur Terminierung
    \item \textbf{Speicherbedarf} Anzahl während Berechnung besuchter Bandzellen 
    \\
    \item TM $M$ \textbf{entscheidet} $L \subset \Sigma^*$ wenn $M$ $w \in L$ akzeptiert und $w \notin L$ verwirft
        (hält stets)
    \\
    \item Jede TM kann durch eine TM mit einseitig beschränktem Band (benutzt nie Positionen $p<0$) simuliert werden.
        Dies hat nur konstanten Overhead. (Siehe HA 2.3)
\end{itemize}
\strut

\textbf{Definition:} rekursive / T-berechenbare Funktionen

$f : \Sigma^* \to \Sigma^*$ heißt rekursiv bzw (T-)berechenbar,\\
wenn es eine TM gibt welche bei Eingabe $x \in \Sigma^*$ stets $f(x)$ berechnet.

\strut
\textbf{Definition:} rekursive / T-entscheidbare Sprachen

Eine Sprache $L \subseteq \Sigma^*$ heißt rekursiv bzw (T-)entscheidbar,\\
wenn es eine TM gibt welche stets terminiert und $w \in \Sigma^*$ akzeptiert gdw. $w \in L$.

\newpage

\textbf{Definition:} Konfiguration

Eine Konfiguration einer TM ist ein String $\alpha q \beta$, wobei $\alpha,\beta \in \Gamma^*,q \in Q$
wobei $\beta \neq \eps$.\\
$\alpha$ entspricht dem Wort links vom Kopf, 1. Symbol von $\beta$ unter dem Kopf (evtl. $B$), Rest von $\beta$ rechts vom Kopf. Blanks werden dabei ausgelassen (außer es steht unter
dem Kopf).

$\alpha'q'\beta'$ ist \textbf{direkte Nacholgerkonfiguration} von $\alpha q \beta$,\\
wenn sie in einem Rechenschritt aus $\alpha q \beta$ entsteht. Man schreibt $\alpha q\beta \vdash \alpha'q'\beta'$.

Analog schreibt man für endlich viele (auch 0) Rechenschritte $\alpha q \beta \vdash^* \alpha''q''\beta''$.

\strut

\textbf{Techniken zur Programmierung TM's (1):} Speicher im Zustandsraum

Zu $k \in \mathbb{N}_{>0}$ können wir $k$ Symbole des Bandalphabets $\Gamma$ im Zustand abspeichern,\\
indem wir den Zustandsraum um den Faktor $|\Gamma|^k$ vergrößern, d.h.
$$
    Q_{neu} := Q \times \Gamma^k
$$
Bspw sind neue Zustände für $k = 2$ dann $(q_0, BB)$ oder $(q_1, 01)$ (wenn $0,1 \in \Gamma$).

\strut

\textbf{Techniken zur Programmierung TM's (2):} Mehrspurmaschinen

$k$-spurige TM: TM mit zusätzlich $k$-Vektoren als Symbole für $k \in \mathbb{N}$. Man schreibt
$$
    \Gamma_{neu} := \Gamma \cup \Gamma^k
$$

\strut

\textbf{Techniken zur Programmierung TM's (3):} Weiteres
\begin{itemize}
    \item Variablen: pro Variable eine Spur
    \item Arrays: ebenfalls in einer Spur möglich
    \item Unterprogramme: eine Spur als Prozedurstack benutzen
\end{itemize}

\newpage

\section{Turing Maschinen II}
\begin{itemize}
    \item $k$-Band-TM's
    \item Simulation von $k$-Band-TM's mit 1-Band-TM's
    \item Gödelnummern
    \item Universelle TM
    \item Church-Turing-These
\end{itemize}

\textbf{Definition:} $k$-Band-TM

Besitzt $k \in \mathbb{N}_{>0}$ Arbeitsbänder mit unabhängigen Köpfen.
Zustandsübergangsfunktion ist dann
$$
    \delta : (Q\setminus \{\overline{q}\}) \times \Gamma^k \to Q \times \Gamma^k \times \{R,L,N\}^k
$$
Dabei ist Band 1 das Eingabe / Ausgabeband. Die anderen sind zunächst leer (Blanks).

\strut

\textbf{Satz:} Simulation von $k$-Band TM's durch 1-Band-TM's

Eine $k$-Band TM $M$ mit Zeitbedarf $t(n)$ und Platzbedarf $s(n)$ kann mit einer 1-Band-TM $M'$
in Zeitbedarf $\mathcal{O}(t^2(n))$ und Platzbedarf $\mathcal{O}(s(n))$ simuliert werden.

Also \textbf{quadratischer Zeitverlust} und \textbf{konstanter Speicherverlust}.

Bewies via $2k$ Spuren; Inhalt der Bänder und Positionen der Köpfe (markiert mit \#).\\
Jeder Rechenschritt von $M$ wird wie folgt durch $M'$ simuliert:
\begin{itemize}
    \item Kopf steht auf linkestem \#, $M'$ kennt Zustand von $M$.
    \item Laufe nach rechts und speichere alle Zeichen an den Kopfpositionen auf den
        zugehörigen Bändern
        im Zustand.
    \item Werte damit $\delta_M$ aus
    \item Laufe zurück und verändere entsprechend Kopfpositionen / Bandinhalte
    \\
    \item Nach $t$ Schritten von $M$ können \#'s höchstens $2t$ Positionen auseinanderliegen
    \item Simulation eines Schrittes also in $\mathcal{O}(t(n))$
    \item Für $t(n)$ Schritte damit $\mathcal{O}(t(n)^2)$
\end{itemize}

\newpage

\textbf{Definition:} Gödelnummer

Die Gödelnummer einer TM $M$ wird durch $\langle M \rangle$ bezeichnet.

\begin{itemize}
    \item Eindeutige, \textbf{präfixfreie} Kodierung über $\{0,1\}$.
    \item $\langle M \rangle$ beginnt und endet stets mit 111, enthält sonst 111 nicht.
    \item Man beschränkt sich auf TM's mit $Q= \{q_1,q_2,\cdots,q_t\}, t \geq 2$\\
        wobei $q_1,q_2$ Anfangs-/Endzustand sind. Ferner soll $\Gamma = \{0,1,B\}$.

        Man kodiert den $t$-ten Übergang mit $code(t)$ in der Form $0^a10^b10^c10^d10^e$
        (Siehe Folien).\\
        Dann kodiert man die TM $M$ mit $s$ Übergängen durch:
        $$
            \langle M \rangle = 111code(1)11code(2)11\dots 11code(s)111
        $$
\end{itemize}

\strut

\textbf{Definition:} Universelle Turingmaschine

Eingabe ist ein Wort der Form $\langle M\rangle w$ für $w \in \{0,1\}^*$.

Simulation via 3-Spur TM in \textbf{konstanter Zeit} möglich: Gödelnr auf Spur 2, Zustand auf 3.

\strut

\textbf{Behauptung:} Church-Turing-These (1930)

Die Klasse der TM-berechenbaren Funktionen stimmt mit der Klasse der\\
''intuitiv berechenbaren'' Funktionen überein.

Daher (in dieser Vorlesung)
$$
    \text{berechenbare Funktion} = \text{TM-berechenbare Funktion} = \text{rekursive Funktion}
$$$$
    \text{entscheidbare Sprache} = \text{TM-entscheidbare Sprache} = \text{rekursive Sprache}
$$

\newpage

\section{Registermaschinen}

\begin{itemize}
    \item Registermaschinen
    \item Kostenmaße
    \item Simulation RAM durch TM
    \item Simulation TM durch RAM
    \item Collatz Problem
\end{itemize}

\textbf{Definition:} Registermaschine (RAM)

Besteht aus Befehlszähler, Akkumulator (c(0)), unbeschränkter Speicher c(1),c(2),...\\
Programme haben Befehlssatz:

(IND/C)LOAD, (IND)STORE, (IND/C)ADD, (IND/C)SUB, (IND/C)MULT, (IND/C)DIV

IF c(0) ? x THEN GOTO j \qquad wobei j Zeile im Programm und $? \in \{=,<,\leq,\geq,>\}$

GOTO, END


\begin{itemize}
    \item Inhalt des Speichers sind Elemente von $\mathbb{N}$ (beliebig groß)
    \item Eingabe ebenfalls in $\mathbb{N}^*$, zu Beginn ''in den ersten Registern''.
    \item Andere Register mit 0 initialisiert.
    \item Befehlszähler startet mit 1. Als nächstes wird immer die Zeile, auf die der Befehlszähler
        verweist, ausgeführt.
    \item Rechnung stoppt sobald END ausgeführt wird.
    \item Ausgabe befindet sich dann ''in den ersten Registern''.
\end{itemize}

\strut

\textbf{Definition:} Kostenmaße für RAM's

\textbf{Uniformes Kostenmaß:} Jeder Schritt / Befehl zählt eine Zeiteinheit

\textbf{Logarithmisches Kostenmaß:} Die Laufzeitkosten eines Schrittes sind Maximum der\\
Logarithmen der involvierten Zahlen. (Maximale Zahlenlänge)

\newpage

\textbf{Satz:} Simulation von RAM durch TM

Für jede im logarithmischen Kostenmass $t(n)$-zeitbeschränkte RAM $R$ gibt es ein Polynom $q$
und eine $q(n + t(n))$-zeitbeschränkte TM $M$, welche $R$ simuliert.

Simulation hat also \textbf{polynomiellen Overhead}. Beweisidee:
\begin{itemize}
    \item 2-Band-TM. Band 1 für Unterprogramme, Band 2 Inhalt der Register.
    \item Unterprogramme für Initialisierung, Ergebnisausgabe und jede Programmzeile.
    \item Befehlszähler im Zustand speichern.
    \item Simulation von einem Schritt: Sei $b$ Zustand.
        \begin{enumerate}
            \item Kopiere inhalt der in Programmzeile $b$ angesprochenen Registern auf Band 1.
            \item Führe via Unterprogramm der Zeile $b$ entsprechende Operationen durch.
            \item Kopiere Ergebnisse zurück in die in $b$ angegebenen Register auf Band 2.
            \item Aktualisiere Programmzähler (Inkrement oder GOTO)
        \end{enumerate}
    \item Alle Unterprogramme Laufzeit polynomiell in der Länge von Band 2 (benutzte
        Register). Also: Eine Laufzeit polynomiell in $n + t(n)$.
    \item Dank Abschlusseigenschaften ist die Gesamtlaufzeit dann
        auch polynomiell in $n+ t(n)$.
\end{itemize}

\strut

\textbf{Satz:} Simulation von TM durch RAM

Jede $t(n)$-zeitbeschränkte TM kann durch eine RAM simuliert werden,
die Zeitbeschränkt ist durch
$$
    \mathcal{O}(t(n)+n)\qquad \text{(uniformes Kostenmaß)}
$$$$
    \mathcal{O}((t(n)+n)\cdot \log(t(n)+n))
    \qquad \text{(logarithmisches Kostenmaß)}
$$
Beweisidee:
\begin{itemize}
    \item O.b.d.A. TM mit 1-seitig beschränktem Band. (Positionen $\mathbb{N}$)
    \item Nummeriere Zustände und Symbole zum Speichern in Registern.
    \item Reg 1 für Index des Kopfes, Reg 2 für Zustand,
        Reg $n+3$ für Bandinhalt an Pos. $n$, $n \in \mathbb{N}$.
    \item Programm besteht aus if-Abfragen von Zustand und gelesenem Symbol, die
        dann entsprechende Register verändern (Nachahmen von $\delta$).
    \item UNIFORM: Initialisierung in $\mathcal{O}(n)$, ein Schritt hat konstante Laufzeit,
        also $\mathcal{O}(n+t(n))$
    \item LOG: Banspositionen beschränkt durch $\mathcal{O}(\log(t(n)+n))$,
        also $\mathcal{O}((t(n)+n)\log(t(n)+n))$.
\end{itemize}

\strut

\textbf{Problem:} Collatz-Problem

Wird folgende Funktion bei wiederholter Anwendung stets bei jeder Eingabe
den Wert 1 erreichen?
$$
    f : \mathbb{N} \to \mathbb{N}, x \mapsto
    \begin{cases}
        \frac{x}{2} &, x \text{ gerade}\\
        3x+1 &, x \text{ ungerade}
    \end{cases}
$$


\newpage

\section{Unentscheidbarkeit I}

\begin{itemize}
    \item Abzählbarkeit
    \item Entscheidungsprobleme
    \item Diagonalsprache
    \item Unterprogrammtechnik
    \item Komplement und Entscheidbarkeit
    \item Halteproblem
\end{itemize}

\textbf{Definition:} Abzählbarkeit

Eine Menge $M$ heißt abzählbar, wenn
$$
    M = \varnothing\quad \lor\quad \exists c : \mathbb{N} \to M \text{ surj.}
$$
Wissenswertes:
\begin{itemize}
    \item Wenn $M$ abzählbar unendlich, gibt es eine Bijektion zwischen $\mathbb{N}$ und $M$.
    \item $\mathbb{N}, \mathbb{Z}, \mathbb{Q}$ abzählbar.
    \item $\{0,1\}^*$ ist abzählbar in der \textbf{kanonischen Reihenfolge}
        $\eps, 0,1, 00, 01, 10, 11, 000, \dots$.
    \item Damit Menge der Gödelnummern und Menge der TM's ist abzählbar.
    \\
    \item $i$-tes Wort der kanonischen Reihenfolge über $\{0,1\}$ ist $w_i$.
    \item $i$-te TM der kanonischen Reihenfolge der Gödelnummern ist $M_i$.
    \\
    \item $\mathcal{P}(\mathbb{N})$ ist überabzählbar (Diagonalargument).
    \item $\mathbb{N}^* = \bigcup_{n \in \mathbb{N}}\mathbb{N}^n$ ist abzählbar. (Codiere binär
        wie Gödelnr, dann Teilmenge von $\{0,1\}^*$)
    \item Die Menge aller entscheidbaren Sprachen ist abzählbar (da TM's abzählbar).
    \item Die Menge der unentscheidbaren Sprachen ist überabzählbar.
    \item Die Menge aller Funktionen $f : \mathbb{N} \to \mathbb{N}$ ist überabzählbar
        (Nachkommastellen in $(0,1)_\mathbb{R}$)
\end{itemize}

\strut

\textbf{Bemerkungen:} Entscheidungsprobleme

\begin{itemize}
    \item Jedes $L \subseteq \{0,1\}^*$ entspricht Entscheidungsproblem über binär-codiertem
        Alphabet.
    \item Dann ist $\mathcal{L} = \mathcal{P}(\{0,1\}^*)$ Menge aller Entscheidungsprobleme
        überabzählbar.
    \item Da TM's abzählbar, gibt es unentscheidbare Probleme.
\end{itemize}

\newpage

\textbf{Definition:} Diagonalsprache

Die Diagonalsprache ist definiert durch:
$$
    D := \{w \in \{0,1\}^* \mid w = w_i \text{ und } M_i \text{ akzeptiert } w \textbf{ nicht}\}
$$
Diese Sprache ist \textbf{unentscheidbar} (Diagonalargument). Beweis:

Angenommen entscheidbar, dann ex. $j \in \mathbb{N}$ mit $M_j$ entscheidet $D$. Dann
$$
    w_j \in D \,\Longrightarrow\, M_j \text{ akzeptiert } w_j \,\Longrightarrow\, w_j \notin D
$$
Ebenso
$$
    w_j \notin D \,\Longrightarrow\, M_j \text{ akzeptiert } w_j \text{ nicht }
    \,\Longrightarrow\, w_j \in D
$$
Beides Widerspruch, also Annahme falsch, also unentscheidbar.

Das Komplement
$$
    \overline{D} = \{w \in \{0,1\}^* \mid w = w_i \text{ und } M_i \text{ akzeptiert } w\}
$$
ist ebenfalls unentscheidbar. (Allein schon, da entscheidbares abgeschl. unter Komplement).

\strut

\textbf{Definition:} Unterprogrammtechnik

Beweistechnik zur Unentscheidbarkeit. Nehme an Problem ist entscheidbar. Benutze TM, welche dieses
Problem entscheidet als Unterprogramm um ein bekanntlich unentscheidbares Problem zu entscheiden.
Widerspruch, Annahme der Entscheidbarkeit muss falsch sein.

\strut

\textbf{Bemerkungen:} Komplement und Entscheidbarkeit.

Per Unterprogrammtechnik folgt sofot,
dass zu einer Sprachen $L \subseteq \{0,1\}^*$ stets gilt
$$
    L \text{ (un-)entscheidbar } \Iff \overline{L} \text{ (un-)entscheidbar }
$$
indem man Output des Unterprogramms negiert.

\strut

\textbf{Problem:} Halteproblem

Das Halteproblem $H$, definiert durch
$$
    H := \{\langle M \rangle w \mid M \text{ hält auf } w\}
$$
ist nicht entscheidbar. Beweisidee: Unterprogrammtechnik, zeige Entscheidbarkeit
des Komplements der Diagonalsprache, $\overline{D}$. Zu einer Eingabe $w$ ermitteln
wir $i \in \mathbb{N}$ mit $w = w_i$ und lassen $M_H$ auf $\langle M_i \rangle w_i$ laufen.
Wenn es verwirft (also $M_i$ nicht auf $w_i$ hält), verwerfen wir, sonst lassen wir einfach
$M_i$ auf $w_i$ laufen und übernehmen den Output.

\newpage

\section{Unentscheidbarkeit II}


\begin{itemize}
    \item $\eps$-Halteproblem
    \item Partielle Funktionen
    \item Satz von Rice
\end{itemize}


\textbf{Problem:} Epsilon-Halteproblem

Das $\eps$-Halteproblem $H_\eps$, definiert durch
$$
    H_\eps := \{\langle M \rangle \mid M \text{ hält auf } \eps\}
$$
ist nicht entscheidbar. Beweisidee: Unterprogrammtechnik, zeige Entscheidbarkeit vom normalen Halteproblem $H$.
Aus Eingabe $\langle M \rangle w$ konstruiere $\langle M'\rangle$ von TM $M'$, welche $M$ auf $w$ simuliert
und die Eingabe ignoriert. Lasse dann $M_{H_\eps}$ auf $\langle M'\rangle$ laufen.

\strut

\textbf{Definition:} Partielle Funktionen

TM-berechenbare Funktionen sind partielle Funktionen. TM's halten im allgemeinen nicht.

Die von einer TM $M$ berechnete Funktion ist von der Form
$$
    f_M : \{0,1\}^* \to \{0,1\}^* \cup \{\bot\}
$$
wobei $\bot$ für undefiniert steht, und bedeutet, dass $M$ nicht hält. Speziell Entscheidungsprobleme:
$$
    f_M : \{0,1\}^* \to \{0,1,\bot\}
$$
Dabie steht $0$ für Verwerfen, $1$ für Akzeptieren und $\bot$ für Nicht-Halten.

\newpage

\textbf{Satz:} Satz von Rice (Henry Gordon Rice, 1920-2003)

Sei $\mathcal{R}$ die Menge der TM-berechenbaren partiellen Funktionen.
Betrachte $\varnothing \neq \mathcal{S} \subsetneq \mathcal{R}$.\\
Dann ist
$$
    L(\mathcal{S}) = \{\langle M \rangle \mid M \text{ berechnet eine Funktion aus } \mathcal{S}\}
$$
nicht entscheidbar.
\begin{itemize}
    \item Bsp 1: Sei $\mathcal{S} = \{f_M \mid f_M(\eps) \neq \bot\}$.
        Dann ist $L(\mathcal{S}) = H_\eps$ unentscheidbar.
    \item Bsp 2: Sei $\mathcal{S} = \{f_M \mid \forall w \in \{0,1\}^*: f_M(w) \neq \bot\}$.
        $$
            L(\mathcal{S}) = \{\godel{M} \mid M \text{ hält auf jeder Eingabe}\} =: H_{tot}
        $$
        ist nicht entscheidbar.
    \item Bsp 3: Sei $\mathcal{S} = \{f_M \mid \forall w \in \{0,1\}^*: f_M(w) = 1\}$. Dann ist
        $
            L(\mathcal{S}) = \{\godel{M} \mid L(M) = \Sigma^*\}
        $
        unentscheidbar.
\end{itemize}
Beweisidee:
Unterprogrammtechnik mit $H_\eps$. (Siehe Folien für mehr)

Weitere Anwendungsbsp:
\begin{itemize}
    \item Bsp 4: Sei $L_{17} = \{\godel{M} \mid M \text{berechnet bei Eingabe 17 Ausgabe 42}\}$. Dann ist
        $$
            L_{17} = L(\mathcal{S})\text{ für } \mathcal{S} = \{f_M \mid f_M(\text{bin}(17)) = \text{bin}(42)\}
        $$
        Da $\varnothing \neq \mathcal{S} \subsetneq \mathcal{R}$ ist $L_{17}$ unentscheidbar.
    \item Der Satz von Rice \textbf{sagt nichts über Verhalten der TM aus}.\\
        (Zustand / Anzahl Schritte / genauere Implementierungsdetails).
    \item Konsequenzen: Es ist unentscheidbar, ob ein gegebenes Programm in einer
        Turing-mächtigen Sprache eine gegebene nicht-triviale Spezifikation erfüllt.
    \item \textbf{Variante} (Arbeitsheft). Sei $\mathcal{E}$ eine Eigenschaft, sodass
        rekursiv aufzählbare Sprachen $L_1 \subset L_2$ existieren mit:
        $L_1$ erfüllt $\mathcal{E}$, $L_2$ erfüllt $\mathcal{E}$ nicht. Dann folgt schon, dass
        $$
            L_\mathcal{E} := \{\godel{M} \mid L(M) \text{ erfüllt } \mathcal{E}\}
        $$
        nicht rekursiv aufzählbar ist.
    \item \textbf{Variante} (Arbeitsheft) Sei $\mathcal{E}$ eine Eigenschaft, sodass
        eine unendliche rekursive Aufzählbare Sprache $L$ existiert, welche
        die Eigenschaft $\mathcal{E}$ hat. Weiter soll
        $$
            \forall L' \subseteq L: L \text{ endlich}
            \,\Longrightarrow\,
            L \text{ erfüllt } \mathcal{E} \text{ nicht}
        $$
        Dann ist die Sprache
        $$
            L(\mathcal{E}) := \{\godel{M} \mid L(M) \text{ erfüllt }\mathcal{E}\}
        $$
        nicht rekursiv aufzählbar.
\end{itemize}


\newpage

\section{Rekursive Aufzählbarkeit}

\begin{itemize}
    \item TM erkennt / Semi-Entscheidbarkeit
    \item Aufzähler
    \item Rekursive Aufzählbarkeit
    \item rek. aufzählbar $\Iff$ semi-entscheidbar
    \item Abschlusseigenschaften (semi-)entscheidbarer Sprachen
    \item Reduktionen und Übertragungseigenschaften
    \item Totales Halteproblem
\end{itemize}

\textbf{Definition:} TM Erkennt / Semi-entscheidbar

Eine Sprache $L$ wird von einer TM $M$ erkannt, wenn $M$ jedes Wort aus $L$ akzeptiert
und $M$ kein Wort akzeptiert, welches nicht in $L$ liegt.
\begin{itemize}
    \item ''Also: Die von $M$ erkannte Sprache ist genau $L(M)$''.
    \item Wenn eine TM existiert, die eine Sprache $L$ erkennt, so ist $L$ semi-entscheidbar.
    \item Insbesondere gilt $L$ entscheidbar $\,\Longrightarrow\,$ $L$ semi-entscheidbar.
    \item Bsp: Das Halteproblem ist semi-entscheidbar. (Einfach simulieren).
\end{itemize}

\strut

\textbf{Definition:} Aufzähler

Ein Aufzähler für eine Sprache $L \subseteq \Sigma^*$ ist eine TM mit Drucker.
Die TM wird ohne Eingabe mit leerem Band gestartet und gibt mit der Zeit alle Wörter in $L$
aus (mögl. Wiederholungen).

Ausgegebene Wörter werden durch ein Trennzeichen $\# \notin \Sigma$ separiert.

Der Drucker druckt ausschließlich Wörter aus $L$.

\strut

\textbf{Definition:} Rekursive Aufzählbarkeit

Wenn es für eine Sprache $L$ einen Aufzähler gibt,
so wird $L$ als rekursiv aufzählbar bezeichnet.

\strut

\textbf{Satz:} Äquivalenz semi-entscheidbar und rekursiv aufzählbar

Zu einer Sprache $L$ haben wir
$$
    \exists M: M \text{ erkennt } L
    \Iff L \text{ semi-entscheidbar }
    \Iff L \text{ rekursiv aufzählbar }
$$

\newpage

\textbf{Satz:} Abschlusseigenschaften der (Semi-)Entscheidbarkeit
\begin{itemize}
    \item (Semi-)Entscheidbare Sprachen sind unter $\cup,\cap$ abgeschlossen.
    \item $L$ und $\overline{L}$ rekursiv aufzählbar $\,\Longrightarrow\,$ $L$ entscheidbar.
    \item Entscheidbare Sprachen sind unter Komplementbildung abgeschlossen.
    \item Semi-entscheidbare Sprachen sind \textbf{nicht} unter Komplementbildung abgeschlossen.

        Betrachte dazu bspw $H$ rekursiv aufzählbar, aber nicht entscheidbar.
\end{itemize}

\strut

\textbf{Definition:} Reduktion

Seien $L_1,L_2$ Sprachen über einem Alphabet $\Sigma$. Dann heißt $L_1$ auf $L_2$ reduzierbar ($L_1 \leq L_2$)\\
wenn es eine berechenbare Funktion $f : \Sigma^* \to \Sigma^*$ gibt mit
$$
    \forall w \in \Sigma^* : w \in L_1 \Iff f(w) \in L_2
$$

\strut

\textbf{Satz:} Übertragungseigenschaften von Reduktionen

Für zwei Sprachen $L_1,L_2 \subseteq \Sigma^*$ gilt
$$
    (L_1 \leq L_2) \land (L_2 \text{ entscheidbar / rek. aufzählbar})
    \,\Longrightarrow\, L_1 \text{ entscheidbar / rek. aufzählbar}
$$
ebenso gilt
$$
    (L_1 \leq L_2) \land (L_1 \text{ nicht entscheidbar / rek. aufzählbar})
    \,\Longrightarrow\, L_1 \text{ nicht entscheidbar / rek. aufzählbar}
$$
ferner haben wir
$$
    L_1 \leq L_2 \,\Longrightarrow\, \overline{L_1} \leq \overline{L_2}
$$

\strut

\textbf{Problem:} Totales Halteproblem ($H_{tot}$)

Das totale Halteproblem $H_{tot}$ ist definiert durch
$$
    H_{tot} := \{\godel{M} \mid M \text{ hält auf jeder Eingabe} \}
$$
Es sind $H_{tot}$ und $\overline{H_{tot}}$ nicht rekursiv aufzählbar.

Beweisidee: Zeige $\overline{H_\eps} \leq H_{tot}$ und $\overline{H_\eps} \leq \overline{H_{tot}}$.

Letzteres trivial mit Reduktion, bilde $\godel{M}$ auf $\godel{M'}$ ab, wobei $M'$ Eingabe ignoriert
und $M$ mit Eingabe $\eps$ simuliert. Bilde ausserdem Müll auf Müll ab.

Ersteres:
Wir bilden Müll auf ein festes Wort $w \in H_{tot}$ ab. Sonst sei $f(\godel{M}) = \godel{M'}$,
wobei $M'$ bei Eingaben der Länge $\ell$ die ersten $\ell$ Schritte von $M$ bei Eingabe $\eps$ simuliert.
Hält $M$ in diesen, so geht $M'$ in Endlosschleife, andernfalls hält $M'$.

\newpage

\section{Postsches Correspondenzproblem}


\begin{itemize}
    \item Postsches Correspondezproblem (PCP)
    \item Einschränkungen des PCP's
\end{itemize}

\strut

\textbf{Problem:} Postsches Correspondenzproblem (PCP)

Eine Instanz des PCP besteht aus eine endlichen Menge
$$
    K = \{\left[\frac{x_1}{y_1}\right], \cdots, \left[\frac{x_k}{y_k}\right]\}
    \quad \text{ für }\quad
    x_1,\dots,x_k,y_1,\dots,y_k \in \Sigma^+ = \Sigma^* \setminus \{\eps\}
$$
Elemente von $K$ nennen wir Dominos.
Frage:
$$
    \text{Existiert }\quad
    I = (i_1,i_2,\dots,i_n) \in [1,k]^n
    \quad\text{ mit }\quad
    x_{i_1}x_{i_2}\dots x_{i_n} = y_{i_1}y_{i_2}\dots y_{i_n}
    \quad ?
$$
Die Modizierte Version, das MPCP verlangt nur, dass $I$ mit $i_1 = 1$ beginnt.

Das PCP und MPCP sind \textbf{unentscheidbar}, dazu zeigt man $H$ $\leq$ MPCP $\leq$ PCP.\\
(Details siehe VL).

\strut

\textbf{Probleme:} Einschränkungen des PCP's
\begin{itemize}
    \item Zu Wörtern der Länge 1 ist das PCP entscheidbar.
    \item Wenn alle Wörter Länge 1 oder 2 haben ist das PCP unentscheidbar.
    \\[5pt]
    \item Für 1 oder 2 Dominos ist das PCP entscheidbar
    \item Für 5 Dominos ist das PCP unentscheidbar
    \item Für 7 oder mehr Dominos ist das PCP unentscheidbar
\end{itemize}


\newpage

\section{Turing-Mächtigkeit}


\begin{itemize}
    \item Kontext-freie Grammatik (CFG)
    \item Leerheit Schnitt zweier CFG's
    \item Satz von Richardson (Rationale Funktion als Summe)
    \item Hilberts 10. Problem / Satz von Matiyasevich
    \item Satz von David, Robinson,... (Ganzzahlige Polynome gleichstark wie TM's)
    \item Turing-Mächtigkeit
    \item Conway's Game of Life
\end{itemize}

\textbf{Definition:} Eine kontext-freie Grammatik (CFG) $G$ ist ein Quadrupel $(N, \Sigma, P, S)$
wobei
\begin{itemize}
    \item $N$ die Menge der Non-Terminalsymbole
    \item $\Sigma$ das Terminalalphabet
    \item $P$ die Menge der Regeln der Form $A \to w, A \in N, w \in (\Sigma \cup N)^*$
    \item $S \in N$ das Startsymbol
\end{itemize}

Wir definieren $L(G)$ als die Menge aller Worte über dem Terminalalphabet $\Sigma$, die
durch wiederholte Anwendung von Regeln in $P$ aus dem Startsymbol $S$ hergeleitet werden können.

\strut

\textbf{Problem:} Leerheit des Schnittes der Sprachen zweier CFG's

Es ist unentscheidbar, ob zu zwei CFG's $G_1,G_2$ gilt, dass $L(G_1) \cap L(G_2) = \varnothing$.

Beweisidee:
\begin{itemize}
    \item Betrachte PCP-Instanz
        $\displaystyle\left\{\left[\frac{x_1}{y_1}\right],\dots,\left[\frac{x_n}{y_n} \right]\right\}$.\\
    \item Es seien $a,b,c \notin x_i,y_i \forall i \in [1,n]$.
    \item Konstruiere CFG's $G_1,G_2$ mit folgenden Regeln:
        $$
            G_1:\quad S\mapsto x_1Sa^1b \mid x_2 Sa^2b \mid \dots \mid x_n Sa^nb \mid c
            \qquad
            G_2:\quad S\mapsto y_1Sa^1b \mid y_2 Sa^2b \mid \dots \mid y_n Sa^nb \mid c
        $$
    \item PCP lösbar genau dann, wenn $L_1(G) \cap L_2(G) \neq \varnothing$. Bspw.
        wenn folgende Ableitungen gleich sind:
        $$
            G_1 : S \up{\to}{*} x_1x_4x_2x_5x_1x_4\,c\,a^4ba^1ba^5ba^2ba^4ba^1b
        $$$$
            G_2 : S \up{\to}{*} y_1y_4y_2y_5y_1y_4\,c\,a^4ba^1ba^5ba^2ba^4ba^1b
        $$
\end{itemize}

\newpage

\textbf{Satz:} Satz von Richardson (1968), (Integration in geschlossener Form)

Es ist unentscheidbar, ob eine gegebene elementare Funktion eine elementare Stammfunktion besitzt.

\strut

\textbf{Problem:} Hilberts zehntes Problem (BuK-Formulierung) / Satz von Matiyasevich

Hilberts zehntes Problem handelt von diophantischen Gleichungen und ist beschrieben durch:
$$
    \text{Dioph} =  \{\godel{p} \mid p \text{ ist multivariates Polynom mit ganzzahligen Koeffizienten und ganzzahliger Nullstelle}\}
$$
Nach dem \textbf{Satz von Matiyasevich}(1970) ist \textbf{Dioph unentscheidbar}.

Jedoch ist \textbf{Dioph rekursiv aufzählbar}, was aus der Abzählbarkeit von $\mathbb{Z}^n$ folgt.

\strut

\textbf{Satz:} Satz von Davis, Robinson, Putnam, Matiyasevich. (Ganzzahlige Polynome und TM's)

Der Satz besagt, dass zu $X\subseteq \mathbb{Z}$ gilt:
$$
    X \text{ rek. aufzählbar} \Iff
    \exists p \in \mathbb{Z}[x_1,\dots,x_k] : X = \{x \in \mathbb{Z} \mid \exists y \in \mathbb{Z}^{k-1}: p(x,y) = 0\}
$$
Er sagt aus, dass \textbf{ganzzahlige Polynome so berechnugsstark wie TM's} sind.

\strut

\textbf{Definition:} Turing-Mächtigkeit

Ein Rechnermodell wird als Turing-mächtig bezeichnet, wenn jede TM-berechenbare Funktion
auch durch dieses Rechnermodell berechnet werden kann.

\textbf{RAM's sind Turing-mächtig}

\strut

\textbf{Satz:} Mini-RAM / RAM mit eingeschränktem Befehlssatz ist Turing-mächtig

Die Mini-RAM verfügt nurnoch über \textbf{endlich viele Register} und folgende 8 Befehle:

LOAD, STORE, CLOAD, CADD, CSUB, GOTO, IF $c(0) > 0$ THEN GOTO, END.

Die \textbf{Mini-RAM ist Turing-mächtig}.

\newpage

\textbf{Bemerkungen:} Turing-mächtige Beispiele
\begin{itemize}
    \item Lambda Calculus von Alonzo Church
    \item $\mu$-rekursive Funktionen von Stephen Kleene
    \item Alle gängigen höheren Programmiersprachen (C, Java, etc.)
    \item Postscript, Tex, Latex
    \item Power-Point (wegen Animationen)
\end{itemize}

\strut

\textbf{Definition:} Conway's Game of Life (1970)

Conway's Game of Life ist ein zellulärer Automat, der auf einem unendlichen 2-dimensionalen Gitter
arbeitet. Zu jedem Zeitpunkt ist jede Zelle entweder lebend oder tot.

In jedem Schritt passiert dann:
\begin{itemize}
    \item Eine tote Zelle mit genau 3 lebenden Nachbarn ist im nächsten Schritt lebendig.
    \item Lebende Zellen mit weniger als 2 oder mehr als 3 lebenden Nachbarn sterben.
    \item Alle anderen Zellen bleiben unverändert.
\end{itemize}

\textbf{Conway's Game of Life ist Turing-mächtig}.

\newpage

\section{LOOP und WHILE Programme I}
\begin{itemize}
    \item LOOP
    \item LOOP-Programme
    \item WHILE
    \item WHILE ist Turing-mächtig
    \item LOOP-WHILE
\end{itemize}

\textbf{Definition:} Die Programmiersprache LOOP
\begin{itemize}
    \item Variablen: $x_1,x_2,x_3,\dots$ und $x_0$ zur Ausgabe.
        Eingabe in $x_1,\cdots,x_m$ (mit 0 initialisiert).
    \item Konstanten: 0 und 1
    \item Symbole: :=, +, ;
    \item Keywords: LOOP, DO, ENDLOOP
    \\
    \item $x_i := x_j + c$ für $i,j \in \mathbb{N}, c\in {0,1}$ ist ein LOOP-Programm.
    \item Wenn $P_1,P_2$ LOOP-Programme sind, dann ist $P_1;P_2$ ein LOOP-Programm.
    \item Falls $P$ ein LOOP-Programm ist, dann ist LOOP $x_i$ DO $P$ ENDLOOP ein LOOP-Programm.
\end{itemize}
Ein LOOP-Programm $P$ berechnet eine \textbf{totale} $k$-stellige Funktion der Form
$[P] : \mathbb{N}^k \to \mathbb{N}^k$.

\textbf{LOOP-Programme sind nicht Turing-mächtig}

\strut

\textbf{Bemerkungen:} Nützliche LOOP-Programme:
\begin{itemize}
    \item $x_i := x_j$ via $x_i := x_j + 0$.
    \item $x_i := c$ für $c \in \mathbb{N}_0$ via festes $x_{zero} = 0$ und wiederholtem $x_i := x_i + 1$.
    \item $x_0 := x_1 + x_2$ via LOOP-Konstrukt ($x_j := x_j + 1$ einfach $x_k$ mal)
    \item $x_0 := x_1 \cdot x_2$ via LOOP-Konstrukt ($x_0$ Anfangs 0 und dann $x_0 := x_0 + x_1$ genau $x_2$ mal)
    \item $x_0 := x_1 \up{-}{\large.} x_2 = \max(x_1-x_2,0)$
    \item $x_0 := x_1 \text{ DIV } x_2$\quad und\quad $x_0 := x_1 \text{ MOD } x_2$
    \item IF $x_1 = 0$ THEN $P_1$ ELSE $P_2$ ENDIF wie folgt: (IF $x_1 = c$ auch möglich)

        $x_2 := 1; x_3 := 0$;\\
        LOOP $x_1$ DO $x_2 := 0;x_3 := 1$ ENDLOOP;\\
        LOOP $x_2$ DO $P_1$ ENDLOOP;\\
        LOOP $x_3$ DO $P_2$ ENDLOOP;\\
    \item max, min
\end{itemize}

\newpage

\textbf{Definition:} Die Programmiersprache WHILE
\begin{itemize}
    \item Variablen: $x_1,x_2,x_3,\dots$ und $x_0$ zur Ausgabe.
        Eingabe in $x_1,\cdots,x_m$ (mit 0 initialisiert).
    \item Konstanten: 0 und 1
    \item Symbole: :=, +, ;, {\color{red}$\neq$}
    \item Keywords: WHILE, DO, ENDWHILE
    \\
    \item $x_i := x_j + c$ für $i,j \in \mathbb{N}, c\in {0,1}$ ist ein WHILE-Programm.
    \item Wenn $P_1,P_2$ WHILE-Programme sind, dann ist $P_1;P_2$ ein WHILE-Programm.
    \item Falls $P$ ein WHILE-Programm ist, dann ist WHILE $x_i \neq 0$ DO $P$ ENDWHILE ein WHILE-Programm.
\end{itemize}

Ein WHILE-Programm $P$ berechnet eine (nicht unbedingt totale) $k$-stellige Funktion der Form
$[P] : \mathbb{N}^k \to \mathbb{N}^k$.

Jedes LOOP-Programm kann durch ein WHILE-Programm simuliert werden.

\strut

\textbf{Satz:} While-Programme sind Turing-mächtig

Eine äußere Schleife WHILE Zustand $\neq 0$ DO, und dadrin dann mit if-Abfragen $\delta$ simuliert.
(benötigt explizit sogar nur die äußerste While-Schleife, alles andere könnte mit LOOP simuliert werden).

\strut

\textbf{Definition} LOOP-WHILE (HA 7.3)

Die Programmiersprache LOOP-WHILE darf alle LOOP-keywords benutzen, und höchstens einmal
eine WHILE-Schleife.

\textbf{LOOP-WHILE ist Turing-mächtig}, da zur Simulation der Turingmaschine nur effektiv eine WHILE-Schleife
benötigt wird (die äußeste, WHILE Zustand $\neq$ Endzustand DO ...)

\newpage

\section{LOOP und WHILE Programme II}


\begin{itemize}
    \item Ackermann-Funktion
    \item Up-Arrow-Notation
    \item Wachstumsfunktion
    \item Wachstumslemma / LOOP nicht Turing-mächtig
\end{itemize}

\textbf{Definition:} Ackermann-Funktion

Die Ackermann-Funktion $A : \mathbb{N}^2 \to \mathbb{N}$ ist rekursiv wie folgt definiert:
$$
    A(0,n) = n+1
    \qquad\qquad
    A(m+1,0) = A(m,1)
$$$$
    A(m+1,n+1) = A(m, A(m+1,n))
$$
\begin{itemize}
    \item $A(1,n) \equiv n+2$
    \item $A(2,n) \equiv 2n+3$
    \item $A(3,n) \equiv 2^{n+3}-3$
    \item $A(4,n) \equiv \underbrace{2^{2^{.^{.^{.^2}}}}}_{n+3} - 3$
\end{itemize}

Die Ackermann-Funktion ist Turing-berechenbar und streng monoton in beiden Parametern.

\strut

\textbf{Exkurs:} Up-Arrow-Notation (Donald Knuth)
$$
    a \uparrow^m b :=
    \begin{cases}
        1               &, b = 0\\
        a \cdot b       &, m = 0\\
        a^b \cdot b     &, m = 1\\
        a \uparrow^{m-1}(a \uparrow^m(b-1)) &, \text{sonst}
    \end{cases}
$$
Es gilt:
\begin{itemize}
    \item $A(1,n) \equiv 2 + (n+3) - 3$
    \item $A(2,n) \equiv 2 \cdot (n+3) - 3$
    \item $A(3,n) \equiv 2 \uparrow (n+3) - 3$
    \item $A(4,n) \equiv 2 \uparrow\uparrow (n+3) - 3$
    \item $A(m,n) \equiv 2 \uparrow^{m-2} (n+3) - 3$
\end{itemize}

\newpage

\textbf{Definition:} Wachstumsfunktion

Zu einem LOOP-Programm $P$ und Inputs $a \in \mathbb{N}^k$ definiert man
$
    f_P(a) := \sum_{i=1}^{k} b_i
$
als die Summe der Ergebniswerte von $P$ bei Eingabe $a$, also $b = [P](a)$.
Die Wachstumsfunktion ist dann gegeben durch:
$$
    F_P(n) := \max\left\{f_P(a) \mid a \in \mathbb{N}^k, \sum_{i=1}^{k} a_i \leq n\right\}
$$

\strut

\textbf{Satz:} Wachstumslemma

Sei $P$ ein LOOP-Programm. Dann gilt:
$$
    \exists m_P \in \mathbb{N} : \forall n \in \mathbb{N} : F_P(n) < A(m_P,n)
$$
Beweisidee: Zeige via (algebraische) Induktion, dass:
\begin{itemize}
    \item $m_{x_i := x_j + c} = 2$.
    \item Zu LOOP-Programmen $P,Q$ ist $m_{P;Q} = \max(m_P,m_Q)+1$.
    \item Zu LOOP-Programm $P$ ist $m_{\text{LOOP } x_i \text{ DO } P \text{ ENDLOOP}} = m_P + 1$.
\end{itemize}

Es folgt, dass \textbf{LOOP-Programme nicht Turing-mächtig} sind, da die Ackermann TM-berechenbar,
aber nicht LOOP-berechenbar ist. (wächst zu krass)

\newpage

\section{Primitiv-rekursive Funktionen}


\begin{itemize}
    \item Primitiv-rekursive Funktionen
    \item Prädikatsfunktion
    \item Weitere primitiv-rekursive Funktionen
    \item Bijektion $\mathbb{N}^2 \to \mathbb{N}$
    \item Äquivalenz primitiv-rekursiv und LOOP
    \item Kleenscher $\mu$-Operator
    \item Klasse der $\mu$-rekursiven Funktionen ist Turing-mächtig
\end{itemize}

\textbf{Definition:} Primitiv-rekursive Funktionen

Die primitiv-rekursiven Funktionen setzen sich aus Basifunktionen mittles 2 Operationen
zusammen und bilden eine Unterklasse der Funktionen $\mathbb{N}^k \to \mathbb{N}$.

Die Basisfunktionen sind:
\begin{itemize}
    \item Konstante Funktionen, also $g: \mathbb{N}^k \to \mathbb{N}, x \mapsto c$ für $c \in \mathbb{N}$.
    \item Projektionen, notiert $\pi_{k,i}: \mathbb{N}^k \to \mathbb{N}, x \mapsto x_i$.
    \item Die Nachfolgerfunktion $succ : \mathbb{N} \to \mathbb{N}, x \mapsto x+1$.
\end{itemize}
Komposition von prim.-rek. Funktionen ist wieder prim.-rek.\\
Das heißt, für prim.-rek. Funktionen
$g : \mathbb{N}^a \to \mathbb{N}$ und $h_1,h_2,\dots,h_a : \mathbb{N}^b \to \mathbb{N}$ ist
$$
    f: \mathbb{N}^b \to \mathbb{N}, x \mapsto g(h_1(x), h_2(x), \cdots, h_a(x))
$$
wieder prim.-rek.

Weiter können wir via primitiver Rekursion neue prim.-rek. Funktionen aus alten bauen:\\
Seien $g: \mathbb{N}^k \to \mathbb{N}, h: \mathbb{N}^{k+2} \to \mathbb{N}$ prim.-rek.
Dann ist $f: \mathbb{N}^{k+1} \to \mathbb{N}$, definiert durch:
$$
    f(0,x_1,\cdots,x_k) := g(x_1,\cdots,x_k)
$$$$
    f(n+1,x_1,\cdots,x_k) := h(n, f(n,x_1,\cdots,x_k), x_1,\cdots,x_k)
$$
wieder prim.-rek.

\textbf{Primitiv-rekursive Funktionen sind stets berechenbar und total}.

\strut

\textbf{Notation:} Prädikatsfunktion

Wir schreiben $[x \geq 1]$ für $f : \mathbb{N} \to \{0,1\}, x \mapsto \begin{cases}1 &, x \geq 1\\ 0 &, \text{sonst}\end{cases}$. Generell $[P]$ für ein Prädikat $P$.

\newpage

\textbf{Bemerkung:} Weitere primitiv-rekursive Funktionen

\begin{minipage}{.5\textwidth}
\begin{itemize}
    \item $\text{add}:\mathbb{N}^2 \to \mathbb{N}, (x,y) \mapsto x+y$
    \item $\text{mult}: \mathbb{N}^2 \to \mathbb{N}, (x,y) \mapsto x \cdot y$
    \item $\text{pred}: \mathbb{N} \to \mathbb{N}, x \mapsto \max(x-1, 0)$
    \item $\text{sub}: \mathbb{N}^2 \to \mathbb{N}, (x,y) \mapsto \max(x-y, 0)$
    \item $[x = y], [x < y], [x \leq y] = \text{leq}$
\end{itemize}
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{itemize}
    \item $\text{sgn} = [x \geq 1]$
    \item $\text{binom}(n,k) = \binom{n}{k}$
    \item $\max(x,y), \min(x,y)$
    \item $[x \text{ ungerade}], [x \mid y], [x \text{ prim}]$
    \item $x\text{ mod } y,\quad \text{ggT}(x,y),\quad x\text{ DIV }y = \lfloor\frac{x}{y}\rfloor$
\end{itemize}
\end{minipage}

\strut

\textbf{Bemerkung} Bijektion $\mathbb{N}^2 \to \mathbb{N}$

Wir haben eine \textbf{primitiv-rekursive} Bijektion $\beta : \mathbb{N}^2 \to \mathbb{N}$, gegeben durch
$$
    \beta(x,y) := \binom{x+y+1}{2}+x
$$
Aus dieser lässt sich eine primitiv-rekursive Bijektion $\Omega : \mathbb{N}^{k} \to \mathbb{N}$ bauen, gegeben durch
$$
    \Omega(x_1,\cdots,x_k) := \beta(x_1,\beta(x_2,\beta(x_3,\cdots,\beta(x_{k-1},x_k)\cdots)))
$$

\strut

\textbf{Satz:} Äquivalenz primitiv-rekursiv und LOOP

Die Menge der primitiv-rekursiven Funktionen fällt mit der Menge der LOOP-berechenbaren zusammen.

Beweisidee: LOOP in prim.-rek.:

\begin{itemize}
    \item Zuweisungen via entsprechender Veränderung des Eingabetupels, also
        $$
            P = [x_i := x_j + c] \qquad\text{durch}
        $$$$
            g_P(x) := \Omega(\pi_{k,1}(x),\cdots,\pi_{k,i-1}(x),\pi_{k,j}(x) + c, \pi_{k,i+1}(x), \cdots, \pi_{k,k}(x))
        $$
        Wobei $\Omega:\mathbb{N}^k \to \mathbb{N}$ bijektiv.
    \item Hintereinanderausführung via Komposition, also
        $$
            P = [Q;R] \qquad\text{durch}\qquad g_P(x) := g_R(g_Q(x))
        $$
        Für LOOP-Programme $Q,R$.
    \item LOOPS durch wiederholtes Hintereinanderausführen:
        $$
            P = [\textsc{LOOP } x_i \textsc{ DO } Q \textsc{ ENDLOOP}]
            \qquad\text{durch}\qquad
        $$$$
            g_P(x) := g_Q^{x_i}(x) = \underbrace{g_Q(g_Q(\cdots g_Q(g_Q(x))\cdots))}_{x_i}
        $$
\end{itemize}

\newpage

Rückrichtung: prim.-rek. in LOOP: (Erinnerung: Ausgabe bei LOOP-Programm ist $x_0$)
\begin{itemize}
    \item Konstante Funktionen durch $x_0 := c$.
    \item Projektion $\pi_{k,j}$ durch $x_0 := x_j$.
    \item Nachfolgerfunktion $succ(x_j)$ durch $x_0 := x_j + 1$.
    \item Komposition durch ''geeignetes Hintereinanderausführen''.
    \item Primitive Rekursion (siehe def., gleiche Fkt im folgenden) durch ''bottom-up'':

        $x_0 := g(x_1,\cdots,x_k)$;\\
        $s := 0$;\\
        \textsc{LOOP} $n$ \textsc{DO}\\
        \strut\qquad$x_0 := h(s,x_0,x_1,\cdots,x_k)$;\\
        \strut\qquad$s := s+1$;\\
        \textsc{ENDLOOP};
\end{itemize}

\strut

\textbf{Definition:} Der Kleen'sche $\mu$-Operator

Es gilt im folgenden $\min \varnothing = \bot$.

Es sei $g: \mathbb{N}^{k+1} \to \mathbb{N}$ eine (partielle oder totale) Funktion.
Der $\mu$-Operator ist definiert durch:
$$
    \mu g : \mathbb{N}^k \to \mathbb{N}\cup\{\bot\},
    x \mapsto \min\{n \in \mathbb{N}\mid g(n,x) = 0 \land \forall m < n: g(m,x) \neq \bot\}
$$
Die resultierende Funktion gibt also die kleinste Nullstelle zu den festen letzten $k$ Parametern,
oder $\bot$ wenn diese nicht existiert.

Bspw. ist zu $g: \mathbb{N}^3 \to \mathbb{N}$ mit $g \equiv 1$ dann $\mu g \equiv \bot$

Der $\mu$-Operator lässt sich wiederholt anwenden.

\strut

\textbf{Definition:} Klasse der $\mu$-rekursiven Funktionen

Diese Klasse von (partiellen und totalen) Funktionen ist die kleinste, welche die Basisfunktionen enthält
und abgeschlossen unter Komposition, primitiver-rekursion und des $\mu$-Operators ist.

\newpage

\textbf{Satz:} $\mu$-rekursive Funktionen sind Turing-mächtig

Die Menge der $\mu$-rekursiven Funktionen fällt mit der Menge der WHILE-/TM-/RAM-berechenbaren Funktionen
zusammen.

Beweisidee: Es genügt zu zeigen, dass WHILE-Schleifen und $\mu$-Operatoren sich gegenseitig simulieren können (da restliche Befehle wie bei LOOP sind und schon von primitiv-rekursiven
Funktionen abgedeckt werden).

Man simuliert ein Programm $P$ der Form WHILE $x_i \neq 0$ DO $Q$ ENDWHILE durch
$$
    g_P(x_1, \cdots, x_k)
    := g_Q^{\mu \pi_{k,i}(g_Q^n(x))}(x)
    = \underbrace{g_Q(g_Q(g_Q(\cdots g_Q(x)\cdots)))}_{\mu \pi_{k,i}(\underbrace{g_Q(\cdots g_Q(x)\cdots)}_{n})}
$$
Dies benutzt den $\mu$-Operator, um das kleinste $n \in \mathbb{N}$ zu finden,
sodass nach $\pi_{k,i}(g_Q^n(x)) = 0$ gilt, also die $i$-te Variable nach $n$-maligem Ausführen von $g_Q$
gleich 0 ist (was ja gerade die Abbruchbedingung der While-Schleife ist). Dies kann auch $\bot$ sein, wenn die While-Schleife nicht terminiert.

Das WHILE-Programm zu einer Funktion,
welche aus Anwendung des $\mu$-Operators auf ein $g: \mathbb{N}^{k+1} \to \mathbb{N}$ entstanden ist,
lautet wie folgt:

$x_0 := 0$;\\
$y := g(0,x_1,\cdots,x_k)$;\\
WHILE $y\neq 0$ DO\\
\strut\qquad$x_0 := x_0 +1$;\\
\strut\qquad$y := g(x_0,x_1\cdots,x_k)$;\\
ENDWHILE;

\newpage

\section{P versus NP}

\begin{itemize}
    \item Worst Case Laufzeit
    \item Polynomielle Algorithmen
    \item Komplexitätsklasse \textsf{P}
    \item Non-deterministische Turingmaschinen (NTM's)
    \item Laufzeit einer NTM
    \item Komplexitätsklasse \textsf{NP}
    \item CLIQUE
    \item Zertifikat-Charakterisierung von \textsf{NP}
\end{itemize}

\textbf{Definition:} Worst Case Laufzeit

Die Wort Case Laufzeit eines Algorithmus $A$ sind die maximalen Laufzeitkosten
auf Eingaben der Länge $n$ bezüglich des logarithmischen Kostenmaßes der RAM.
Wir schreiben dazu $t_A(n)$.

\strut

\textbf{Definition:} Polynomielle Algorithmen

Ein Algorithmus $A$ heißt polynomiell (beschränkt), wenn
$$
    \exists \alpha \in \mathbb{N}: t_A(n) \in \mathcal{O}(n^\alpha)
$$

\strut

\textbf{Definition:} Komplexitätsklasse \textsf{P}

\textsf{P} ist die Klasse aller Entscheidungsprobleme, für die es einen polynomiellen
Algorithmus gibt.

\strut

\textbf{Definition:} Non-deterministische Turingmaschine (NTM)

Einziger Unterschied ist die Zustandsübergangs\textbf{relation}, für die nun
$$
    \delta \subseteq ((Q\setminus \{\overline{q}\}) \times \Gamma) \times (Q \times \Gamma \times \{L,R,N\})
$$
Die mögl. Rechenwege einer NTM können in einem Berechnungsbaum zsmgefasst werden.
Dabei entsprechen Knoten Konfigurationen, die Wurzel der Startkonfiguration,
die Kinder einer Konfiguration allen möglichen Nachfolgekonfigurationen.

Wir definieren den maximalen Verzweigungsgrad
$$
    \Delta := \max\{|\delta(q,a)| : q \in Q \setminus \{\overline{q}\}, a \in \Gamma\}
$$
Eine NTM $M$ akzeptiert eine Eingabe $x \in \Sigma^*$,
falls es \textbf{mindestens} einen Rechenweg von $M$ gibt,
indem $M$ die Eingabe $x$ akzeptiert (im Sinne einer normalen TM). Dann ist in diesem Sinne:
$$
    L(M) := \{x \in \Sigma^* \mid M \text{ akzeptiert } x\}
$$

\strut

\textbf{Definition:} Laufzeit einer NTM

Sei $M$ eine NTM und $x \in \Sigma^*$ eine Eingabe. Die Laufzeit $T_M(x)$ ist gegeben durch:
\begin{itemize}
    \item Falls $x \in L(M)$, so ist $T_M(x)$ die Länge des \textbf{kürzesten akzeptierenden} Rechenweges.
    \item Falls $x \notin L(M)$, so ist $T_M(x) := 0$.
\end{itemize}
Die \textbf{Worst Case Laufzeit} der NTM $M$ auf Eingaben der Länge $n$ ist dann
$$
    t_M(n) := \max\{T_M(x) \mid x \in \Sigma^n\}
$$

\strut

\textbf{Definition:} Komplexitätsklasse \textsf{NP}

\textsf{NP} ist die Klasse alle Entscheidungsprobleme,
die durch eine NTM $M$ erkannt werden,
deren Worst Case Laufzeit $t_M(n)$ polynomiell beschränkt ist.

\strut

\textbf{Problem:} CLIQUE

Eingabe: Ein ungerichteter Graph $G = (V,E)$ und $k \in \mathbb{N}$.\\
Frage: Enthält $G$ eine Clique (vollständigen Teilgraph) mit $\geq k$ Knoten?

Es gilt CLIQUE $\in \textsf{NP}$. Beweisidee: Eine NTM $M$ mit $L(M) = $ CLIQUE geht wie folgt vor:
\begin{itemize}
    \item Syntaxcheck
    \item Rate non-deterministisch einen 0-1-String $y$ der Länge $|V|$.
    \item M akzeptiert, falls der String $y$ mindestens $k$ Einsen enthält und die Knotenmenge
        $C := \{i \in V \mid y_i = 1\}$ eine Clique bildet.
\end{itemize}

\strut\\

\textbf{Satz:} Zertifikat Charakterisierung von \textsf{NP}

Eine Sprache $L \subseteq \Sigma^*$ liegt genau dann in \textsf{NP}, wenn es
einene polynomiellen deterministischen Algorithmus $V$ und ein Polynom $p$ gibt, sodass:
$$
    x \in L \Iff \exists y \in \{0,1\}^*, |y| \leq p(|x|): y\#x \in L(V)
$$
$V$ heißt hier Verifizierer, das Wort $y \in \{0,1\}^*$ Zertifikat.

\newpage

\section{Polynomielle Reduktionen}

\begin{itemize}
    \item Lösungen zu SAT konstruieren
    \item Optimierungsprobleme
    \item \textsf{EXPTIME}
    \item \textsf{NP} $\subseteq$ \textsf{EXPTIME}
    \item Polynomielle Reduktionen
\end{itemize}

\textbf{Satz:} Lösungen zu SAT konstruieren

Wir betrachten SAT Instanzen mit $n$ Variablen und $m$ Klauseln. Angenommen, Algorithmus $A$ entscheidet
SAT Instanzen in $T(n,m)$ Zeit. Dann gibt es einen Algorithmus $B$, der zu erfüllbaren SAT Instanzen
in $n\cdot T(n,m)$ eine Variablenbelegung konstruiert.

Beweisidee: Lege die Variablen einzeln fest und überprüfe ob die Formel erfüllbar bleibt.

\strut

\textbf{Definition:} Optimierungsprobleme

Die Eingabe eines Optimierungsproblems spezfiziert eine Menge $\mathcal{L}$ von zulässigen Lösungen
zusammen mit einer Zielfunktion $f : \mathcal{L} \to \mathbb{N}$, die Kosten, Gewicht, oder Profit misst.
Das Ziel ist dann, eine Optimale Lösung in $\mathcal{L}$ zu bestimmen.

Diese Probleme lassen sich oft in ''sehr ähnliche'' Entscheidungsprobleme umwandeln.
Hierbei fügt man dem Problem eine Schranke hinzu und fragt dann, ob es eine Lösung gibt,
welche dieser Schranke genügt.

Am Beispiel KP (Rucksackproblem): Angenommen $A \in \textsc{P}$ löst das zugehörige Entscheidungsproblem
\begin{itemize}
    \item Bestimme mit binärer Suche den optimalen Zielfunktionswert\\
        (min. Profit 0, max. Summe aller Profite). Dies ist immernoch polynomiell
    \item Bestimme beste Gegenstandswahl durch $n+1$ Aufrufe des letzten Algoritmus:\\
        Teste ob optimaler Wert erreichbar wenn wir Gegenstand $k \in [1,n]$ nicht mitnehmen.
\end{itemize}

\strut

\textbf{Definition:} \textsf{EXPTIME}

\textsf{EXPTIME} ist die Klasse aller Entscheidungsprobleme,
die durch eine DTM $M$ entschieden werden, dessen Worst Case Laufzeit $t(n)$
durch $2^{q(n)}$ mit einem Polynom $q$ beschränkt ist.

Laufzeit-Beispiele: $2^{\sqrt{n}}, 2^n, 3^n, n!, n^n$

\newpage

\textbf{Satz:} $\textsf{NP} \subseteq \textsf{EXPTIME}$

Beweisidee:
\begin{itemize}
    \item Sei $L \in \textsf{NP}$. Benutze Zertifikat-Charakterisierung und erhalte Verifizierer $V \in \textsf{P}$.
    \item Nummeriere alle möglichen Zertifikate $y \in \{0,1\}^*$  mit $|y| \leq p(|x|)$ und teste jedes mit $V$.
    \item Es gibt ca. $2^{p(|x|)}$ von diesen möglichen Zertifikaten,
        und $V$ ist polynomiell in $|x| + |y|$
    \item Damit ist die Gesamtzeit ca. $poly(|x|)\cdot 2^{p(|x|)}$
\end{itemize}

\strut

\textbf{Definition:} Polynomielle Reduktionen

Es seien $L_1,L_2 \subseteq \Sigma^*$. Dann ist $L_1$ polynomiell reduzierbar auf $L_2$, geschrieben $L_1 \leq_p L_2$,
wenn ein polynomiell berechenbares $f : \Sigma^* \to \Sigma^*$ existiert sodass:
$$
    \forall x \in \Sigma^* : x \in L_1 \Iff f(x) \in L_2
$$
Analog zu den Entscheidbarkeitsreduktionen ergibt sich:
$$
    (L_2 \in \textsf{P}) \land (L_1 \leq_p L_2) \,\Longrightarrow\, L_1 \in \textsf{P}
$$

\newpage

\section{Satz von Cook und Levin}

\begin{itemize}
    \item \textsf{NP}-Schwierigkeit
    \item \textsf{NP}-Vollständigkeit
    \item SAT ist \textsf{NP}-vollständig (Cook \& Levin)
    \item Kochrezept für \textsf{NP}-Vollständigkeitsbeweise
    \item 3-SAT + \textsf{NP}-Vollständigkeit
\end{itemize}

\textbf{Definition:} \textsf{NP}-Schwierigkeit

Ein Problem $L$ heißt \textsf{NP}-schwer (\textsf{NP}-hard) falls gilt:
$$
    \forall L' \in \textsf{NP} : L' \leq_p L
$$
Es folgt sofort
$$
    (L \text{ \textsf{NP}-schwer}) \land (L \in \textsf{P}) \,\Longrightarrow\, \textsf{P} = \textsf{NP}
$$
sowie
$$
    (L^* \text{ \textsf{NP}-schwer}) \land (L^* \leq_p L) \,\Longrightarrow\, L \text{ \textsf{NP}-schwer}
$$

\strut

\textbf{Definition:} \textsf{NP}-vollständig

Ein Problem $L$ heißt \textsf{NP}-vollständig (\textsf{NP}-complete) falls $L \in \textsf{NP}$ und $L$ 
\textsf{NP}-schwer.

Die Klasse der \textsf{NP}-vollständigen Probleme wird mit \textsf{NPC} bezeichnet.

\strut

\textbf{Satz:} SAT ist \textsf{NP}-vollständig (Cook \& Levin)

Beweisidee:
\begin{itemize}
    \item Betrachte zu $L \in \textsf{NP}$ eine NTM $M$ mit $L(M) = L$.
    \item Kodiere Verhalten von $M$ in Variablen:
        \begin{enumerate}
            \item Variablen $Q(t,q)$, die 1 sind, gdw. $M$ zum Zeitpunkt $t$ in Zustand $q$.
            \item Variablen $H(t,j)$, die 1 sind, gdw. Kopf an Position $j$ zum Zeitpunkt $t$.
            \item Variablen $B(t,j,a)$, die 1 sind, gdw zum Zeitpunkt $t$ in Zelle $j$ das Symbol $a$ steht.
        \end{enumerate}
    \item Erstelle Klauseln:
        \begin{enumerate}
            \item Zu jedem Zeitpunkt beschreiben die Variablen valide Konfiguration.
            \item Konfiguration bei Zeit $t+1$ entsteht legal aus der zur Zeit $t$.
            \item Start-/Endkonfiguration sind legal.
        \end{enumerate}
    \item Geht alles in polynomiell vielen Klauseln aus jeweils polynomiell vielen Literalen.
\end{itemize}

\newpage

\textbf{Kochrezept:} Kochrezept für \textsf{NP}-Vollständigkeitsbeweise

\begin{enumerate}
    \item Man zeige $L \in \textsf{NP}$.
    \item Man wähle eine \textsf{NP}-vollständige Sprache $L^*$.
    \item (Reduktionsabbildung): Man konstruiere eine Funktion $f$, die Instanzen von $L^*$ auf
        Instanzen von $L$ abbildet.
    \item (Polynomielle Zeit): Man zeige, dass $f$ polynomiell beschränkt ist.
    \item (Korrektheit): Man beweise, dass $f$ tatsächlich eine Reduktion ist
        (also $L^* \leq_p L$).
\end{enumerate}

\strut

\textbf{Problem:} 3-SAT + \textsf{NP}-Vollständigkeit

3-SAT ist wie SAT, nur dass alle Formeln in 3-CNF (jede Klausel genau 3 Terme) sein müssen.

Beweisidee:
\begin{itemize}
    \item 3-SAT $\in \textsf{NP}$ als Spezialfall von SAT.
    \item Klauseln mit $< 3$ Termen durch Variablenwiederholung aufstocken.\\
        Klauseln mit $> 3$ Termen durch Hilfsvariablen trennen:
        $$
            (x_1 + x_2 + x_3 + x_4)
            \qquad\rightarrow\qquad
            (x_1 + x_2 + h) + (\overline{h} + x_3 + x_4)
        $$
    \item Offensichtlich polynomiell und korrekt.
\end{itemize}

\strut

\textbf{Bemerkung} Richard Manning Karp's Liste mit 21 \textsf{NP}-vollständigen Problemen

Die Probleme dieser Liste, welche in der VL drankamen, sind zu Anfang des Dokuments
in der Liste der \textsf{NP}-Probleme {\color{red} rot markiert}.

\newpage

\section{\textsf{NP}-vollständige Graphprobleme}


\begin{itemize}
    \item CLIQUE ist \textsf{NP}-vollständig
    \item INDEP-SET ist \textsf{NP}-vollständig
    \item VERTEX-COVER ist \textsf{NP}-vollständig
    \item D-HAM-CYCLE ist \textsf{NP}-vollständig
    \item HAM-CYCLE ist \textsf{NP}-vollständig
    \item TSP, $\Delta$-TSP und $\{1,2\}$-TSP sind \textsf{NP}-vollständig
\end{itemize}


\textbf{Satz:} CLIQUE ist \textsf{NP}-vollständig

Beweisidee: Man reduziert SAT $\leq_p$ CLIQUE.

\begin{itemize}
    \item Jedes Literal wird mit der aussagenlogischen Formel entspricht einem Knoten
    \item Knoten haben eine Kante gdw. Sie in verschied. Klauseln vorkommen
        und sich nicht widersprechen ($x_2, \lnot x_2$ würde sich widersprechen).
    \item Bei $m$ Klauseln sucht man nun eine CLIQUE von $m$ Knoten in dem resultierenden Graph,
        die Eingabe $k$ für CLIQUE wird also auf $m$ gesetzt.
    \item Die Reduktion ist offensichtlich polynomiell.
\end{itemize}

\strut

\textbf{Satz:} INDEP-SET ist \textsf{NP}-vollständig

Beweisidee: Zeige CLIQUE $\leq_p$ INDEP-SET via $f(V,E,k) := (V,V^2 \setminus E, k)$.

\strut

\textbf{Satz:} VERTEX-COVER ist \textsf{NP}-vollständig

Beweisidee: Zeige INDEP-SET $\leq_p$ VERTEX-COVER via $f(V,E,k) := (V,E,|V|-k)$.

\strut

\textbf{Satz:} D-HAM-CYCLE ist \textsf{NP}-vollständig

Beweisidee: Diamantengadgets, siehe VL-Folien für mehr Details.

\strut

\textbf{Satz:} HAM-CYCLE ist \textsf{NP}-vollständig

Beweisidee: Zeige D-HAM-CYCLE $\leq_p$ HAM-CYCLE, indem man jeden Knoten
des gerichteten Graphen auf 3 Knoten (input, mid, output) des ungerichteten Graphen abbildet.

\newpage

\textbf{Satz:} TSP, $\Delta$-TSP und $\{1,2\}$-TSP sind \textsf{NP}-schwer.

Beweisidee: Es genügt zu zeigen, dass $\{1,2\}$-TSP \textsf{NP}-schwer ist. 
\begin{itemize}
    \item Zeige HAM-CYCLE $\leq_p \{1,2\}$-TSP.
    \item Jeder Knoten des Eingabegraphen wird zu einer ''Stadt''
    \item Setze $\forall u,v \in \text{Städte}: d(u,v) := \begin{cases}1 &, (u,v) \in E\\ 2 &, (u,v) \notin E\end{cases}$
    \item Graph hat Hamiltonkreis gdw. TSP-Instanz eine Tour mit Länge $\leq |V_G|$ hat.
\end{itemize}

\newpage

\section{\textsf{NP}-vollständige Zahlprobleme}


\begin{itemize}
    \item SUBSET-SUM ist \textsf{NP}-vollständig
    \item PARTITION ist \textsf{NP}-vollständig
    \item BPP ist \textsf{NP}-vollständig
    \item KP ist \textsf{NP}-vollständig
    \item Kodierungen
    \item Number
    \item Pseudo-polynomielle Zeit
    \item Stark \textsf{NP}-schwer
    \item THREE-PARTITION + stark \textsf{NP}-schwer
\end{itemize}

\textbf{Satz:} SUBSET-SUM ist \textsf{NP}-vollständig

Beweisidee: Man zeigt 3-SAT $\leq_p$ SUBSET-SUM.
\begin{itemize}
    \item Codierte Zahlen mit $n+m$ Ziffern, wo wir $n$ Variablen und $m$ Klauseln haben.
    \item Für jede Variable $x_i$ erstelle 2 Zahlen $a_i^+, a_i^-$, dessen $i-te$ Ziffer
        1 ist, sonst 0. Ferner hat jede der erstellten Ziffern eine 1 im Ziffernbereich $n+j, j \in [1,m]$
        wenn die zugehörige Variable in Klausel $c_j$ vorkommt. Man führt noch 2 dummy-variablen $d_j,d_j'$
        für jede Klausel ein, welche nur an Ziffer $n+j$ eine 1 haben (eine Klausel kann 3 mal die gleiche Variable enthalten bspw.)
    \item Die Zielsumme lautet dann $b = \underbrace{11...1}_{n}\underbrace{33...3}_{m}$.
    \item Für $i \in [1,n]$ kann die $i$-te Ziffern nur von $a_i^+,a_i^-$ auf 1 gebracht werden,
        insbesondere muss genau eine der beiden Zahlen gewählt werden. Somit wird implizit auch
        jede Klausel mindestens einmal gewählt, was genügt um mit den Dummy-Variablen auf den Wert 3 zu kommen.
    \item Polynomiell da Eingabe $n+m$ Dinge (Variablen / Klauseln) hat und damit Länge $\geq n+m$.
        Die konstruierte Instant benötigt $\mathcal{O}(n+m)$ Zahlen der Länge $n+m$. Die Reduktion erfolgt
        also in $\mathcal{O}((n+m)^2)$.
\end{itemize}

\newpage

\textbf{Satz:} PARTITION ist \textsf{NP}-vollständig

Beweisidee: Man zeige SUBSET-SUM $\leq_p$ PARTITION.
\begin{itemize}
    \item Bilde Instanz $(a_1,...,a_n,b)$ von SUBSET-SUM auf $(a_1,...,a_n,a_{n+1},a_{n+2},b)$ mit
        $a_{n+1} := 2S - b, a_{n+2} := S + b$, wobei $S := \sum_{i=1}^{n} a_i$.
        Dann ist $\sum_{i=1}^{n+2} a_i = 4S$.
    \item Wenn es eine Lösung zur SUBSET-SUM Instanz gibt, fügen wir $a_{n+1} = 2S-b$ hinzu
        und erhalten den gesuchten Summenwert $2S = 4S/2$.
    \item Wenn es eine Lösung zur PARTITION Instanz gibt, so sind $a_{n+1},a_{n+2}$ nicht in der
        selben Teilmenge, da $a_{n+1}+a_{n+2} > 2S$. Da die Teilmenge mit $a_{n+1} = 2S-b$
        die Gesamtsumme $2S$ hat, gibt es also eine Teilmenge der $a_i, i\in [1,n]$ mit Gesamtsumme
        $2S - a_{n+1} = b$.
\end{itemize}

\strut

\textbf{Satz:} BPP ist \textsf{NP}-vollständig

Beweisidee: Man zeige PARTITION $\leq_p$ BPP. Die Instanz $a_1,...,a_n$ mit $\sum_{i=1}^{n} a_i = 2A$
bildet man auf die BPP Instanz mit Gewichten $w_i = a_i$, maximaler Tragkraft $B = A$ und maximaler
Anzahl an Kisten $\gamma = 2$ ab.

\strut

\textbf{Satz:} KP ist \textsf{NP}-vollständig

Beweisidee: Man zeige SUBSET-SUM $\leq_p$ KP. Die Instanz $a_1,...,a_n,b$ von SUBSET-SUM
bildet man auf die KP Instant mit Gewichten $w_i = a_i$, Profiten $p_i = a_i$, sowie Tragkraft
$B$ und minimaler Gesamtprofit $\gamma = B = b$. Die Gewichte überschreiten $b$ nicht,
was $\sum a_i \leq b$ versichert, und der Profit soll mindestens $b$ sein, was dann
$\sum a_i \geq b$ garantiert.

\strut

\textbf{Anmerkung:} Kodierungen
\begin{itemize}
    \item Kodierungslänge einer Instanz eines Problems ist die Anzahl der Symbole in
        einer ''vernünftigen'' Beschreibung. Polynomiell große Änderungen
        in dieser sind für die Resultate der VL irrelevant.
    \item Bspw Graphen; Adjazenzlisten $\ell_1(G) = \mathcal{O}(|E| \log |V|)$ und
        Adjazenzmatrizen $\ell_2(G) = \mathcal{O}(|V|^2)$. Dann ist $\ell_1(G)$ polynomiell
        beschränkt in $\ell_2(G)$ und vice versa.
    \item Zahlen: $\log_a(n) = \underbrace{\log_a(b)}_{\text{konst. Faktor}} \cdot \log_b(n)$ für $a,b > 1$.
    \item Wert eine Zahl $n$ hängt \textbf{exponentiell} von seiner Kodierungslänge ab.
\end{itemize}

\newpage

\textbf{Definition:} Number

Für eine Instanz $I$ eines Entscheidungsproblems ist $Number(I)$ der \textbf{Wert} der größten
in $I$ vorkommenden Zahl. Bspw für TSP die längste Distanz, für SUBSET-SUM $\max\{a_1,...,a_n,b\}$
und für SAT $\max\{n,m\}$.\\
Der Parameter ist eher irrelevant in Problemen ohne Zahlen, wie bspw SAT.

\strut

\textbf{Definition:} Pseudo-polynomielle Zeit

Ein Algorithmus $A$ löst ein Problem $X$ in pseudo-polynomieller Zeit, falls die Laufzeit von
$A$ auf Instanzen $I$ von $X$ polynomiell in $|I|$ und $Number(I)$ beschränkt ist.

\strut

\textbf{Anmerkung:} SUBSET-SUM, PARTITION, KP sind pseudo-polynomiell lösbar

\strut

\textbf{Definition:} Stark \textsf{NP}-schwer

Ein Entscheidungsproblem $X$ ist stark \textsf{NP}-schwer, wenn es ein Polynom $p : \mathbb{N}\to \mathbb{N}$
gibt, sodass $X$ eingeschränkt auf Instanzen $I$ mit $Number(I) \leq p(|I|)$ immernoch \textsf{NP}-schwer ist.\\
(obwohl in diesem Fall alle Zahlenwerte der Instanz $I$ nur polynomiell in $|I|$ sind).\\
Stark \textsf{NP}-schwere Probleme sind bspw: SAT, HAM-CYCLE, TSP, BPP.

\strut

\textbf{Satz:} Beweismethode \textsf{P = NP}

Es sei $X$ ein stark \textsf{NP}-schweres Entscheidungsproblem. Falls $X$ pseudo-polynomiell lösbar ist,
so gilt \textsf{P = NP}.A\\
Dies liegt

\strut

\textbf{Problem:} THREE-PARTITION + stark \textsf{NP}-schwer

Eingabe: Positive ganze Zahlen $a_1,...,a_n,b_1,...,b_n,c_1,...,c_n$ mit $\sum (a_i+b_i+c_i) = nS$.\\[5pt]
Frage: Gibt es zwei Permutationen $\pi,\sigma \in S_n$ sodass $a_{\pi(i)} + b_{\sigma(i)} + c_i = S$
für $i \in [1,n]$ ?

Dieses Problem ist stark \textsf{NP}-schwer.

\newpage

\section{}

\end{document}
